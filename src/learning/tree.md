---
title: 树
icon: tree
order: 1
---

## 简介

**树（Tree）** 是一种非线性的数据结构，用于表示具有层次、父子关系的数据，是算法竞赛中最重要且常用的数据结构之一。

## 概念

### 基础概念

```
          1
         / \
        2   3
       / \   \
      4   5   6
     /       / \
    7       8   9
```

对于任意树，有以下概念：

| 概念 | 定义 | 示例 |
|------|------|---------|
| **节点** | 树中的基本单位，表示数据元素 | 图中的 `1, 2, 3, 4, 5, 6, 7, 8, 9` 都是节点 |
| **边** | 连接两个节点的线，表示节点之间的关系 | 图中的连接线都是边，如连接节点 `1` 和 `2` 的线 |
| **度** | 与节点相连的边的数量 | 节点 `1` 的度是 $2$，节点 `6` 的度是 $3$ |
| **路径** | 从一个节点到另一个节点经过的节点序列 | 从节点 `2` 到节点 `6` 的路径是 `2 -> 1 -> 3 -> 6` |

如果指派 `1` 为根节点，则该树为有根树，有以下概念：

| 概念 | 定义 | 示例 |
|------|------|---------|
| **根** | 树的最顶层节点，是唯一没有父节点的节点 | 节点 `1` 是整个树的根 |
| **子节点** | 一个节点指向的下一层节点 | 节点 `2` 和 `3` 是节点 `1` 的子节点 |
| **父节点** | 一个节点所来自的上一层节点 | 节点 `1` 是节点 `2` 和 `3` 的父节点 |
| **兄弟** | 具有相同父节点的节点 | 节点 `2` 和 `3` 是兄弟；节点 `4` 和 `5` 是兄弟 |
| **叶子** | 没有子节点的节点 | 节点 `5, 7, 8, 9` 是叶节点 |
| **祖先** | 从根到该节点路径上的所有节点 | 节点 `1` 和 `2` 都是节点 `7` 的祖先 |
| **后代** | 以该节点为根的子树中的所有节点 | 节点 `4, 5, 7` 都是节点 `2` 的后代 |
| **深度** | 节点到根节点的路径长度 | 节点 `7` 的深度是 $3$（也可以是 $4$，取决于定义中是否计入根节点） |
| **子树** | 在有根树中，子树指：以某个节点为根，断开该节点与其父节点的连接后形成的树 | 以节点 `2` 为根的子树包括节点 `2, 4, 5, 7` |

### 特殊的树

- **有根树**：有指定根节点的树，大部分题目中会指定根节点为 `1`，要仔细阅读题目要求
- **二叉树**：每个节点最多有两个子节点的树，通常会区分为左子节点和右子节点
- **链**：每个节点最多有一个子节点的树，整棵树形成一条链状结构，类似链表
- **菊花**：存在唯一中心节点，其余节点均为叶子，形成菊花状结构

### 基础性质

- **边与节点的关系**：树中有 $n$ 个节点，就有 $n-1$ 条边
- **连通性**：树是连通的，任意两个节点之间都是连通的
- **无环性**：树是无环的，不存在从某个节点出发又回到该节点的简单路径
- **唯一路径**：任意两个节点之间有且仅有一条简单路径

## 存储

算法竞赛中，最常用的存树方式是 **邻接表** 和 **链式前向星**，通常不使用指针来存储树的边。这里介绍 **邻接表**。

使用 `vector<int>` 存储每个节点的邻接节点列表。

不同题目中，常见的输入格式有以下两种：

### 方式一：给出 n-1 条边

```
n
u_1 v_1
u_2 v_2
...
u_n-1 v_n-1
```

表示有 `n` 个节点的树，有 `n-1` 条边，每条边连接节点 `u_i` 和节点 `v_i`

```cpp
const int MAXN = 500005;
vector<int> tree[MAXN]; // 邻接表
int n;                  // 节点数量

int main()
{
    cin >> n;
    for (int i = 1; i < n; ++i)
    {
        int u, v;
        cin >> u >> v;
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
}
```

**注意**：这种方式存储的树没有指派具体的根节点，因为在给出边时没有指定方向，我们无法判断谁父子节点。相应的，一条边会被存 $2$ 次，我们可以在后续遍历过程中确认父子关系。

### 方式二：给出父节点编号

```
n
p_2
p_3
...
p_n
```

表示有 `n` 个节点的树，节点 `1` 是根节点，节点 `i` 的父节点是 `p_i`

```cpp
const int MAXN = 500005;
vector<int> tree[MAXN]; // 邻接表
int n;                  // 节点数量

int main()
{
    cin >> n;
    for (int i = 2; i <= n; ++i)
    {
        int p;
        cin >> p;
        tree[p].push_back(i);
    }
}
```

### 处理带权边

如果树的边带有权值（如长度、费用等），可以使用 `vector<pair<int, int>>` 来存储邻接表。一般而言，`pair<int, int>` 的第一个元素表示邻接节点编号，第二个元素表示连接到该节点的边的权值。

```
n
u_1 v_1 w_1
u_2 v_2 w_2
...
u_n-1 v_n-1 w_n-1
```

表示有 `n` 个节点的树，有 `n-1` 条边，每条边连接节点 `u_i` 和节点 `v_i`，边权为 `w_i`

```cpp
const int MAXN = 500005;
vector<pair<int, int>> tree[MAXN]; // 邻接表
int n;                             // 节点数量

int main()
{
    cin >> n;
    for (int i = 1; i < n; ++i)
    {
        int u, v, w;
        cin >> u >> v >> w;
        tree[u].emplace_back(v, w);
        tree[v].emplace_back(u, w);
    }
}
```

### 存在多测的情况

可以在每组测试数据中清空需要用到的邻接表部分：

```cpp
const int MAXN = 500005;
vector<int> tree[MAXN]; // 邻接表
int n;

void solve()
{
    cin >> n;
    for (int i = 1; i <= n; ++i)
        tree[i] = vector<int>(); // 清空邻接表

    // 读入边 ...
}
```

也可以使用 `vector<vector<int>>` 代替`vector<int> tree[MAXN]`：

```cpp
vector<vector<int>> tree; // 邻接表
int n;

void solve()
{
    cin >> n;
    tree.assign(n + 1, vector<int>()); // 重新初始化邻接表

    // 读入边 ...
}
```

## 遍历

树的遍历通常使用 **深度优先搜索（DFS）** 或 **广度优先搜索（BFS）**，最常用的遍历方式是 DFS。

### 深度优先搜索（DFS）

```cpp
void dfs(int u, int from)
{
    // 遍历前的操作     *A
    for (int v : tree[u])
        if (v != from) // 避免回到父节点
        {
            // 递归遍历子节点 之前的操作
            dfs(v, u); // 递归
            // 递归遍历子节点 之后的操作
        }
    // 遍历后的操作     *B
}
```

提到 DFS 的时候，往往会提到 **先序遍历**、**中序遍历** 和 **后序遍历**。这三种遍历方式的区别在于对节点的处理时机不同：

- **先序遍历**：在 **位置 A** 处理当前遍历到的节点 `u`
- **中序遍历**：只适用于二叉树，在遍历左子树后、右子树前处理当前节点 `u`
- **后序遍历**：在 **位置 B** 处理当前遍历到的节点 `u`

<!-- todo 补充介绍三种遍历 -->

---

DFS 解决各类树上问题的基石，可以在遍历的过程中维护各种信息，如节点的深度、子树大小、父节点以及更多复杂信息，在树上 DP 中尤为重要。

下面介绍一些示例：

```cpp
vector<int> tree[MAXN];
int n;

int fa[MAXN],  // fa[u] 表示节点 u 的父节点
    dep[MAXN], // dep[u] 表示节点 u 的深度（这里定义根节点深度为 0）
    sz[MAXN],  // sz[u] 表示节点 u 的子树大小（包含节点 u 本身）
    deg[MAXN], // deg[u] 表示节点 u 的子节点数量
    hei[MAXN]; // hei[u] 表示节点 u 的子树高度（即从节点 u 到其最深叶节点的距离）

void dfs(int u, int from)
{
    fa[u] = from;
    dep[u] = (from == -1 ? 0 : dep[from] + 1);
    sz[u] = 1;
    deg[u] = 0;
    hei[u] = 0;
    for (int v : tree[u])
        if (v != from)
        {
            ++deg[u];
            dfs(v, u);
            sz[u] += sz[v];
            hei[u] = max(hei[u], hei[v] + 1);
        }
}

int main()
{
    cin >> n;

    // 读入边 ...

    dfs(1, -1); // 假设节点 1 是根节点
}
```

仔细阅读上面的代码，理解每个信息是如何在 DFS 过程中被维护并计算出来的。特别关注每行代码所处的位置，理解其时机和作用。

---

对于带权边的树，可以在遍历子节点的时候使用`for (auto [v, w] : tree[u])`来获取邻接节点和边权。下面的示例代码用于计算节点到根节点的距离 `dist[u]`：

```cpp
vector<pair<int, int>> tree[MAXN]; // 带权边的邻接表
int n,
    dist[MAXN]; // 距离数组

void dfs(int u, int from)
{
    for (auto [v, w] : tree[u])
        if (v != from)
        {
            dist[v] = dist[u] + w;
            dfs(v, u);
        }
}

int main()
{
    cin >> n;
    for (int i = 1; i < n; ++i)
    {
        int u, v, w;
        cin >> u >> v >> w;
        tree[u].emplace_back(v, w);
        tree[v].emplace_back(u, w);
    }

    dist[1] = 0;
    dfs(1, -1);
}
```

---

下面提供一些习题，练习树的读入与存储、基于 DFS 的树上信息维护：

- [洛谷 B3642](https://www.luogu.com.cn/problem/B3642)
- [Codeforces 913B](https://codeforces.com/problemset/problem/913/B)
- [Codeforces 862B](https://codeforces.com/problemset/problem/862/B)
- [洛谷 P2052](https://www.luogu.com.cn/problem/P2052)


### 广度优先搜索（BFS）

<!-- todo 补充 BFS 介绍 -->

下面提供一些习题，练习树上 BFS 的应用：

- [洛谷 P5908](https://www.luogu.com.cn/problem/P5908)
- [Codeforces 2070D](https://codeforces.com/contest/2070/problem/D)

## 最近公共祖先

参考 [OIWiki - 最近公共祖先](https://oi-wiki.org/graph/lca/)

## 树链剖分

参考 [OIWiki - 树链剖分](https://oi-wiki.org/graph/hld/)